/*
 * Copyright 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <cassert>

#include "demo_scene.h"
#include "imgui.h"
#include "imgui_manager.h"
#include "adpf_manager.h"
#include "native_engine.h"

#include "Log.h"

#include <functional>

extern "C" {
#include <GLES2/gl2.h>
}

#define ARRAY_COUNTOF(array) (sizeof(array) / sizeof(array[0]))

namespace {
    const ImVec4 TEXTCOLOR_WHITE = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    const ImVec4 TEXTCOLOR_GREY = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
    const ImVec4 TEXTCOLOR_RED = ImVec4(1.0f, 0.2f, 0.2f, 1.0f);
    const ImVec4 TEXTCOLOR_GREEN = ImVec4(0.2f, 1.0f, 0.2f, 1.0f);
}

// String lable that represents thermal state.
const char*  thermal_state_label[] = {
        "THERMAL_STATUS_NONE",
        "THERMAL_STATUS_LIGHT",
        "THERMAL_STATUS_MODERATE",
        "THERMAL_STATUS_SEVERE",
        "THERMAL_STATUS_CRITICAL",
        "THERMAL_STATUS_EMERGENCY",
        "THERMAL_STATUS_SHUTDOWN"
};


DemoScene::DemoScene() {
    mSimulatedClickState = SIMULATED_CLICK_NONE;
    mPointerDown = false;
    mPointerX = 0.0f;
    mPointerY = 0.0f;
    mTransitionStart = 0.0f;
    mRegisteredStatusCallback = false;
}

DemoScene::~DemoScene() {
}

void DemoScene::OnStartGraphics() {
    mTransitionStart = Clock();
}

void DemoScene::OnKillGraphics() {
}

void DemoScene::OnScreenResized(int width, int height) {
}

void DemoScene::DoFrame() {
    // clear screen
    glClearColor(0.0f, 0.0f, 0.25f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDisable(GL_DEPTH_TEST);

    // Update ADPF status.
    ADPFManager::getInstance().Monitor();

    // Update UI inputs to ImGui before beginning a new frame
    UpdateUIInput();
    ImGuiManager *imguiManager = NativeEngine::GetInstance()->GetImGuiManager();
    imguiManager->BeginImGuiFrame();
    RenderUI();
    imguiManager->EndImGuiFrame();

    glEnable(GL_DEPTH_TEST);
}

void DemoScene::RenderBackground() {
    // base classes override this to draw background
}

void DemoScene::OnPointerDown(int pointerId, const struct PointerCoords *coords) {
    // If this event was generated by something that's not associated to the screen,
    // (like a trackpad), ignore it, because our UI is not driven that way.
    if (coords->isScreen) {
        mPointerDown = true;
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerMove(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen && mPointerDown) {
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerUp(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen) {
        mPointerX = coords->x;
        mPointerY = coords->y;
        mPointerDown = false;
        mSimulatedClickState = SIMULATED_CLICK_NONE;
    }
}

void DemoScene::UpdateUIInput() {
    ImGuiIO &io = ImGui::GetIO();
    io.MousePos = ImVec2(mPointerX, mPointerY);
    bool pointerDown = false;
    // To make a touch work like a mouse click we need to sequence the following:
    // 1) Position cursor at touch spot with mouse button still up
    // 2) Signal mouse button down for a frame
    // 3) Release mouse button (even if touch is still held down)
    // 4) Reset to allow another 'click' once the touch is released
    if (mSimulatedClickState == SIMULATED_CLICK_NONE && mPointerDown) {
        mSimulatedClickState = SIMULATED_CLICK_DOWN;
    } else if (mSimulatedClickState == SIMULATED_CLICK_DOWN) {
        pointerDown = true;
        mSimulatedClickState = SIMULATED_CLICK_UP;
    }
    io.MouseDown[0] = pointerDown;
}

void DemoScene::RenderUI() {
    SetupUIWindow();

    ImGui::End();
    ImGui::PopStyleVar();
}

void DemoScene::SetupUIWindow() {
    ImGuiIO &io = ImGui::GetIO();
    const float windowStartY = NativeEngine::GetInstance()->GetSystemBarOffset();
    ImVec2 windowPosition(0.0f, windowStartY);
    ImVec2 minWindowSize(io.DisplaySize.x * 0.95f, io.DisplaySize.y);
    ImVec2 maxWindowSize = io.DisplaySize;
    ImGui::SetNextWindowPos(windowPosition);
    ImGui::SetNextWindowSizeConstraints(minWindowSize, maxWindowSize, NULL, NULL);
    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoResize |
                                   ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove;
    ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize, 32.0f);
    char titleString[64];
    snprintf(titleString, 64, "ADPF Sample");
    ImGui::Begin(titleString, NULL, windowFlags);

    RenderPanel();
}

void DemoScene::RenderPanel() {
    int32_t thermal_state = ADPFManager::getInstance().GetThermalStatus();
    assert(thermal_state>=0 && thermal_state < sizeof(thermal_state_label) / sizeof(thermal_state_label[0]));

    // Show current thermal state on screen.
    ImGui::Text("Thermal State:%s", thermal_state_label[thermal_state]);

}
void DemoScene::OnInstall() {
    ALOGI("Setting status and motion data callbacks");
    mRegisteredStatusCallback = true;
}

void DemoScene::OnUninstall() {
    ALOGI("Clearing status and motion data callbacks");
    mRegisteredStatusCallback = false;
}

void DemoScene::OnButtonClicked(int buttonId) {
    // base classes override this to react to button clicks
}
